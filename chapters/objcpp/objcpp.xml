<?xml version="1.0" encoding='ISO-8859-1'?><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"                      "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [<!ENTITY % hppxents SYSTEM "../../HPPX.ent">%hppxents;]><chapter id="OBJCPP"> 	<title>Back Together Again: Objective-C++</title><para>Mixing C and Objective-C code has never been a problem on &osx;. In fact,some of the functionality provided by &cocoa; is simply a wrapper aroundC-based Carbon libraries. This means you can mix and match C code asappropriate in your applications. There are plenty of reasons you mightwant to fall back on C. Most likely, it will be because you either havelegacy code with which you need to inter-operate, or find the need toimplement highly optimized routines. Whatever the reason, for allpractical purposes, Objective-C <emphasis>is</emphasis> C.</para><para>The situation is not as simple with C++. Previously on &osx;, if youwanted to mix Objective-C and C++ you could only use their commondenominator, C. This typically meant programmers had to developcompatibility layers that necessarily strip the object oriented natureof either the Objective-C or C++ libraries, thus rendering much of theirattraction moot. It turns out that NeXT had a version of Objective-Cthat could inter-operate with C++ code called (not surprisingly)Objective-C++, that at first did not make NeXTStep's transition to theMacintosh platform. Apple soon rectified the situation, and later &osx;developer tools include support for the Objective-C++ language.Objective-C++ is not widely advertised by Apple, but it exists, and hasbeen updated to support the current C++ standard.</para><para>Support for Objective-C++ is built into <command>gcc</command> and<application>ProjectBuilder</application>. <application>ProjectBuilder</application> uses the file extension todetermine in which language a file has been written. For Objective-C++,the expected extension is <filename>*.mm</filename>. If you choose <menuchoice>	<guimenu>File</guimenu> 	<guimenuitem>Save As...</guimenuitem></menuchoice>in <application>ProjectBuilder</application> you have theoption of selecting an Objective-C++ file type (See <xref linkend="fig-ocppsaveas"/>).</para><figure id="fig-ocppsaveas">	<title><application>ProjectBuilder</application> File Type for Objective-C++</title>	<mediaobject>	<imageobject>	<imagedata scale="50" align="center" fileref="./chapters/objc/figures/ocpp_save_as.tif" format="EPS"/>	</imageobject>	</mediaobject></figure><para>To get an idea of what Objective-C++ can do, let's look at an example.The following code is the header file for a very simple C++ class called<classname>Widget</classname>:</para><programlisting><![CDATA[#include <string>class Widget { 	friend ostream& operator<<(ostream &os, const Widget &w);public: 	string getName(); 	void setName(string new_name);protected: 	string name; }; ]]></programlisting><para>Notice that the <classname>Widget</classname> class declaration uses the standard</para><programlisting><![CDATA[#include <string>]]></programlisting><para>syntax for include files, as well as the othertraditional fare you would expect for a C++ class. Objective-C++'scompliance with the C++ standard follows from <command>gcc</command>'s support of the standard. Earlier versions of <command>gcc</command> (pre 3.x) had somelimitations in this regard. The current C++ support in <command>gcc</command> ismuch more complete. <classname>Widget</classname> is obviously a pretty simple beast, so we probably won't be stressing the C++ implementation too any greatdegree. It has one member variable: <varname>name</varname>, two methods:<function>getName</function> and <function>setName</function> as well as a single friend function: the overloaded left-shift operator(<literal>&lt;&lt;</literal>).</para><para>The implementation file <filename>widget.cpp</filename> for <classname>Widget</classname> is:</para><programlisting><![CDATA[#include "widget.h"string Widget::getName() { 	return name; }void Widget::setName(string new_name) { 	name = new_name; }ostream& operator<<(ostream &os, const Widget &w) { 	return os << w.name;} ]]></programlisting><para>Again, the <classname>Widget</classname> class implementation follows the standard conventions for C++ programming. <classname>Widget</classname> is a full fledged C++ class in all respects.</para><para>Using this C++ class in our Objective-C++ code turns out to be veryeasy. The following listing is the <filename>main.mm</filename> file for a verysimple application showing how Objective-C++ can mix Objective-C and C++code.</para><programlisting> <![CDATA[#import <Foundation/Foundation.h> #import "widget.h"int main (int argc, const char * argv[]) { 	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];	Widget w; 	NSString* s = @"Widget Number 1";	w.setName([s cString]);	NSLog([NSString stringWithCString:w.getName().c_str()]); 	cout << w << endl;	[pool release]; return 0; } ]]></programlisting><para>Like all Objective-C programs, we start by creating an autorelease poolto take care of any Objective-C objects we might create along the way.Our application then creates two objects&mdash;a <classname>Widget</classname> <varname>w</varname> and an <classname>NSString</classname> <varname>s</varname>. Next, we set <varname>w</varname>'s nameusing <classname>NSString</classname>'s <function>cString</function> selector, which returns a traditional null-terminated <type>char*</type>. Since <classname>Widget</classname>'s <function>setName()</function> method expects a <classname>string</classname>, <classname>string</classname>'sC++ style constructor is implicitly called. We then get <varname>w</varname> tooutput its name using both the <application>Foundation</application> framework's<function>NSLog()</function> function, and C++'s <varname>cout</varname> object. In the case of <function>NSLog()</function>, we have to get a C-style string from <varname>w</varname>, while <varname>cout</varname> uses our overloaded friend <literal>&lt;&lt;</literal>. Finally, we follow proper Objective-C convention and release our pool, and exit out of main.</para><para>Despite this example's small amount of code, there is a lot going onunder the hood. If you take a second to consider what we have just done,it is actually pretty amazing. Without very much fuss, we haveintegrated objects from two different languages. There are a couplefeatures of Objective-C++ that make this transition easy: First,Objective-C++ allows us to program with the full range of bothObjective-C and C++ syntax. We are not limited to a poor-man's subset ofcommonalty. If you want to use the full expressiveness of C++'soperator overloading, feel free to do so. If you want to incorporateDistributed Objects or Objective-C's dynamism, do so as well. Second,while our use of the <classname>Widget</classname> class shows how we can incorporate custom C++ objects, this code also shows how we have all of the standard C++ libraries at our disposal as well. We were able to implicitly andexplicitly use the <classname>string</classname> class and <varname>cout</varname> object.</para><para>If you need to work with existing C++ libraries, <application>ProjectBuilder</application>'s Objective-C++ implementation makes your work fairly painless. There is no need to create a bridging layer of code between your Objective-C and C++ work. In addition, there are a few side benefits to using <application>ProjectBuilder</application>'s Objective-C++ mode. In addition to using C++'s object-oriented features, you can also take advantage of the more mundane changes C++ makes to C syntax. Take the following Objective-C implementation as an example:</para><programlisting><![CDATA[#import "widget.h"@implementation Widget- (void)doSomething { 	NSString *s = @"foo"; 	NSLog(s);	for(int i = 0; i < 10; ++i) { 		// do something clever 	}}@end ]]></programlisting><para>Save it as <filename>widget.m</filename>, and <command>gcc</command> will give you:<computeroutput> <![CDATA[widget.m: In function `-[WidgetdoSomething]': widget.m:10: parse error before `int']]></computeroutput></para><para>However, save the exact same file as <filename>widget.mm</filename>&mdash;an Objective-C++ file type, and <command>gcc</command> will happily compile it. In this case, Objective-C is using the old C rules about where we can declare variables in a block of code, which means that all of our variables must be declared at the <emphasis>beginning</emphasis> of the block. As Objective-C++ code, we get to declare variables anywhere we wish, including within the <literal>for</literal> loop expression. Some programmers have even been known to automatically use the <filename>*.mm</filename> file extension in order to simply avoid the more restrictive syntax of C!<footnote><para>The latest version of <command>gcc</command> does support the declaration of variables other than at the beginning of blocks, although, this doesn't include the <literal>for</literal> loop expression above</para></footnote></para><para>Apart from avoiding C limitations, there are actually more productivereasons for using Objective-C++. Typically, this is to integrate C++ andObjective-C code into a single application. There are many ways that aprogrammer might want to combine Objective-C and C++; however, for thesake of simplicity, I would recommend keeping a safe distance betweenthe Objective-C and C++ portions of your code. It is possible to turnotherwise perfectly well behaved Objective-C classes in hybrid monstersthat devour your productivity. Just because Objective-C++ lets youfreely intermingle C++ and Objective-C code is no reason to abandon gooddesign choices. Good application design will isolate libraries behindwell documented interfaces, so that as implementations change, an entireapplication does not have to be retooled. Objective-C++ provides thebridge with which to create this interface.</para>	<sect1>		<title>Using C++ Classes from Objective-C</title><para>The most common use of Objective-C++ is probably when developers need tointegrate existing C++ libraries into their code. <xref linkend="UHOC:cppfromoc"/> depicts this relationship.</para><figure id="UHOC:cppfromoc">	<title>Calling C++ from Objective-C</title>	<mediaobject>	<imageobject>	<imagedata scale="75" align="center" 	fileref="./chapters/objc/figures/ocpp_cpp_from_oc.pdf" format="EPS"/>	</imageobject>	</mediaobject></figure><para>Take another look at the <filename>main.mm</filename> file from the <classname>Widget</classname> example:</para><programlisting><![CDATA[#import <Foundation/Foundation.h> #import "widget.h"int main (int argc, const char * argv[]) { 	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];	Widget w; 	NSString* s = @"Widget Number 1";	w.setName([s cString]);	NSLog([NSString stringWithCString:w.getName().c_str()]); 	cout << w << endl;	[pool release]; 	return 0; } ]]></programlisting><para>Now, what would you consider this application&mdash;an Objective-C programusing C++ objects, or a C++ program using Objective-C objects? In fact,you could pick either position and be correct. This example is a little<emphasis>too</emphasis> simple, in that no Objective-C or C++ object directlyinteracts with the other language's constructs. If you look closely, weare simply passing around pointers to characters between the objects. Inany real Objective-C application, <function>main()</function> will be a distantmemory up the calling stack, and we will need to interact with our C++libraries from within proper Objective-C objects.</para><para>In this example, we will create a very simple application that combines the use of an Objective-C GUI with a C++ back-end that loads a list of wood stock from a file. You can imagine the C++ backend might be code that accesses a legacy database or proprietary binary file formats. In our case, the files are simple text files holding a series of wood names and counts.</para><figure id="UHOC:cpp_from_oc">	<title>A Simple Table View</title>	<mediaobject>	<imageobject>	<imagedata  scale="50" align="center" 	fileref="./chapters/objc/figures/ocpp_window.tif" format="EPS"/>	</imageobject>	</mediaobject></figure><para>First, we need to properly isolate the portions of our code that will interact with C++ from the portions of our code that will be pure Objective-C. The best way to do this is through the use of <emphasis>protocols</emphasis>. Here is our simple protocol definition:</para><programlisting> <![CDATA[@protocol DataSourceProtocol <NSObject> - (void)loadFilename:(NSString*)filename; @end ]]></programlisting><para>It is this protocol by which the Objective-C GUI will tell the C++ portions of the code to load a file. The basic strategy is this: encapsulate the C++ portions of the code in Objective-C++ objects. Define a protocol to which the Objective-C++ object responds. Connect the Objective-C portions of the code to this hybrid object through an <literal>id</literal> pointer using <application>InterfaceBuilder</application> and let the Objective-C runtime pass messages back and forth between these objects.</para><para>Here is the header file for our Objective-C++ object. In this case, weare interested in using C++'s collection classes from the STL. TheDataSource object is going to hold a pointer to a vector storing theinformation our program is interested in.</para><programlisting> <![CDATA[#import <Cocoa/Cocoa.h> #include <vector>#include <string>#import "DataSourceProtocol.h"@interface DataSource : NSObject <DataSourceProtocol> { 	vector< pair<string, float> > *data; } @end ]]></programlisting><para>The datasource class needs to implement a couple of protocols, both formal and informal, that are not apparent in its header file. The first of these is the tableview data source <emphasis>informal</emphasis> protocol. We need to accept two messages: <command>numberOfRowsInTableView:</command> and <command>tableView:objectValueForTableColumn:row:</command>. In addition, datasource implements the formal protocol we declared in <command>DataSourceProtocol.h</command>, which is the <command>loadFilename:</command> message.</para><programlisting> <![CDATA[#import "DataSource.h" #include <iostream>#include <fstream>@implementation DataSource- (id)init { 	if(self = [super init]) { 		data = new vector< pair< string, float> >;	} 	return self; }- (void)loadFilename:(NSString*)filename { 	ifstream infile([filename cString]); 	string wood; 	float feet;	if(!infile) { 		NSRunAlertPanel(@"Error", 			[NSString stringWithFormat:@"Error Opening File %@", filename], 			nil, nil, nil);		return; 	}	while( infile >> wood ) { 		infile >> feet; 		data->push_back( make_pair< string, float > (wood, feet));	} }- (int)numberOfRowsInTableView:(NSTableView *)aTableView { 	return data->size(); }- (id)tableView:(NSTableView *)aTableViewobjectValueForTableColumn:(NSTableColumn *)aTableColumn row:(int)rowIndex {	if([[aTableColumn identifier] isEqualTo:@"index"])		return [NSString stringWithFormat:@"%d", rowIndex]; 			if([[aTableColumn identifier] isEqualTo:@"wood"]) 		return [NSString stringWithCString:((*data)[rowIndex]).first.c_str()]; 	if([[aTableColumn identifier] isEqualTo:@"feet"]) 		return [NSString stringWithFormat:@"%.2f", ((*data)[rowIndex]).second]; 	return @""; }- (void)dealloc { 	delete data; 	[super dealloc]; }@end ]]></programlisting><para>Notice that in our <function>-init</function> method we dynamically create the C++ vector, and properly dispose of it in our <function>-dealloc</function> method. This is a very important point:</para><blockquote><para> <emphasis>Hold all objects as pointers</emphasis>. Just like your statically typed Objective-C objects, make sure you use pointers to C++ objects as instance variables, instead of the objects themselves. Since the Objective-C run-time isn't familiar with the C++'s object model, it will not be able to properly instantiate the variables. It will not automatically call the C++ constructors and destructors as you are familiar with. By using pointers, you can properly construct the instance variables in your <function>-init</function> method, as well as properly destroy the variable in your <function>-dealloc</function> method. The same goes for Objective-C classes as members of C++ objects.</para></blockquote><para>We now have a completed datasource object that bridges the gap betweenthe C++ <classname>vector</classname> and <classname>pair</classname> classes and Objective-C. It does so without undue exposure to C++ in the rest of the application.</para><para>At this point, we can instantiate it in our nib, and connect it to the table view as the table view's datasource (See <xref linkend="UHOC:ocppnib"/>).</para><figure id="UHOC:ocppnib">	<title>Create an Instance of our Objective-C++ Object <classname>DataSource</classname></title>	<mediaobject>	<imageobject>	<imagedata  scale="50" align="center" 	fileref="./chapters/objc/figures/ocpp_nib.tif" format="EPS"/>	</imageobject>	</mediaobject></figure><para>There are a few things to remember. First, the table view datasource is the Objective-C++ object. Notice that the table view doesn't care. It happily sends messages to the Objective-C++ datasource. This is the advantage of the dynamic nature of Objective-C. Even though tableview is a pure Objective-C object, we can set its datasource outlet to our Objective-C++ object, and it happily trundles away. However, if you were to try to directly set the table view's datasource to the Objective-C++ object programmatically, you would have difficulty getting things to compile. The use of the protocol helps to better define our intentions to the compiler. Also, we cannot include the datasource header file directly in our GUI code since the header has C++ portions that will fail to compile in combination with the Objective-C-only portions of the code as we will see next.</para><para>There is an additional class we need to complete our application. Thatis a controller to load the <classname>NSOpenPanel</classname>, and tell the datasource to load the new data. It uses the formal protocol we defined earlier to do this. Here is the header file:</para><programlisting><![CDATA[#import <Cocoa/Cocoa.h> #import "DataSourceProtocol.h"@interface WoodCountController : NSObject { 	IBOutlet NSTableView* table;	IBOutlet id<DataSourceProtocol> datasource; } - (IBAction)open:(id)sender; @end ]]></programlisting><programlisting> <![CDATA[#import "WoodCountController.h"@implementation WoodCountController- (IBAction)open:(id)sender { 	NSOpenPanel *panel = [NSOpenPanel openPanel]; 	[panel setDelegate:self]; 	[panel setPrompt:@"Open"];	[panel beginSheetForDirectory:nil file:nil types:nil				   modalForWindow:[table window] modalDelegate:self               didEndSelector:@selector(openPanelDidEnd:returnCode:contextInfo:)				      contextInfo:[NSString stringWithString:@"open"]]; }- (void)openPanelDidEnd:(NSOpenPanel*)openPanelreturnCode:(int)returnCode contextInfo:(void*)x { 	if(returnCode == NSOKButton) { 		[datasource loadFilename:[openPanel filename]]; 		[table reloadData]; 	}}@end ]]></programlisting><para>as with the datasource class, create an instance of the<classname>WoodCountController</classname> class in <application>Interface Builder</application> (See <xref linkend="UHOC:ocppnib2"/>), make the outlet connections to <varname>table</varname> and <varname>datasource</varname> and compile.</para><figure id="UHOC:ocppnib2">	<title>Create an Instance of the <classname>WoodCountController</classname> Class</title>	<mediaobject>	<imageobject>	<imagedata scale="50" align="center" 	fileref="./chapters/objc/figures/ocpp_nib2.tif" format="EPS"/>	</imageobject>	</mediaobject></figure><para><xref linkend="UHOC:ocpprunning"/> shows our new mixed Objective-C and C++ application running. In this case, the graphical front end is entirely Objective-C, while the back-end pulling data uses C++ objects and data structures. Objective-C++ has been used to effectively bridge between these to languages.</para><figure id="UHOC:ocpprunning">	<title>Our New Mixed Objective-C and C++ Application Running</title>	<mediaobject>	<imageobject>	<imagedata scale="50" align="center" 	fileref="./chapters/objc/figures/ocpp_running.tif" format="EPS"/>	</imageobject>	</mediaobject></figure>	</sect1>		<sect1>		<title>Using Objective-C Classes from C++</title><para>Most programmers used Objective-C in the past in order to program forNeXTStep, and the same holds true for &osx;<footnote><para>Not to dismiss GNUStep and other Unix operating systems</para></footnote>. When you find yourself needing Objective-C++, 99.9% of the time you will probably be writing a graphical application for &osx;, and needing to integrate your favorite C++ library. A good architecture would dictate proper separation between the two languages by a strong interface. Because of modern GUIs' use of event-driven design, control typically moves through an application from the visible elements, written in Objective-C, to the back-end, where the majority of the C++ code exists. This means that Objective-C code will call the C++ code more often than the other way around.</para><para>In what cases might the situation be reversed?</para><orderedlist><listitem><para>Your application might in fact be written using a mix of C and C++ and the Carbon libraries, and you want to take advantage of something in &cocoa;.</para></listitem><listitem><para> Algorithms or routines in your C++ code need access to data structures best kept in the Objective-C realm.</para></listitem></orderedlist><para>In these cases, it might make more sense to flip our point of view (see<xref linkend="UHOC:ocfromcpp"/>. When we were integrating C++ into ourObjective-C application, we created a bridge by using the C++ structures encapsulated in Objective-C++ classes. For integrating Objective-C code into a C++ program, we will do the reverse. Our bridging code will be written as a C++ class holding pointers to the Objective-C objects we wish to incorporate.</para><figure id="UHOC:ocfromcpp">	<title>Integrating Objective-C into a C++ Program</title>	<mediaobject>	<imageobject>	<imagedata scale="75" align="center" fileref="./chapters/objc/figures/ocpp_oc_from_cpp.pdf" format="EPS"/>	</imageobject>	</mediaobject></figure><para>From C++, Objective-C objects look like exactly what they are: pointers.In other words, you don't change your normal Objective-C object sytax when refering to Objective-C objects in C++.</para><para>We cheated with the previous example by using Interface Builder to side-step the creation of the Objective-C++ object. In this case, we are again avoiding intermingling our C++ code with Objective-C code, except we areusing a factory method with which to accomplish this as you will see later on.</para><para>The following code example shows how a hypothetical C++ stock cutting optimizer might be able to use Objective-C's Distributed Object (DO) support to communicate with a master server.</para><para>The following is the Objective-C class <classname>LClient</classname> that communicates with the server using DO. Its job is act as a proxy for requests up to the server from the C++ optimizer. If you are not familiar with Distributed Objects. they are covered in several chapters, including <olink targetptr="NETWORK" targetdoc="network.xml"/> and <olink targetptr="CLUSTER" targetdoc="cluster.xml"/>.</para><programlisting> <![CDATA[#import <Foundation/Foundation.h> #import "LServerProtocol.h" #import "LClientProtocol.h"@interface LClient : NSObject <LClientProtocol> { 	id server; 	id delegate; } - (id)delegate; - (void)setDelegate:(id)del; - (void)registerWithServerName:(NSString*)serverName hostName:(NSString*)hostName; - (NSDictionary*)getCutList; - (void)completedWork:(NSDictionary*)cutList; @end@interface LClientDelegateProtocol : NSObject { } - (void)serverTerminatingForClient:(LClient*)lClient; @end]]></programlisting><programlisting> <![CDATA[#import "LClient.h"static int runs = 0;@implementation LClient- (id)delegate { 	return delegate; }- (void)setDelegate:(id)del { 	[delegate autorelease]; 	delegate = del; }- (void)registerWithServerName:(NSString*)serverNamehostName:(NSString*)hostName { 	server = [NSConnection rootProxyForConnectionWithRegisteredName:serverName 																			   host:hostName];	[server setProtocolForProxy:@protocol(LServerProtocol)];	[server registerClient:self];}// ClientProtocol Implementation- (void)serverTerminating { 	NSLog(@"terminating"); 	if(delegate)		[delegate serverTerminatingForClient:self]; }// methods encapsulating the server object- (NSDictionary*)getCutList { 	NSLog(@"getting cut list"); 		if(++runs > 5)		[self serverTerminating]; 			return [server getCutList]; }- (void)completedWork:(NSDictionary*)cutList { 	NSLog(@"sending");	[server completedWork:cutList]; }@end ]]></programlisting><para>The Following code is the abstract C++ class that defines a C++ compatible interface into the <classname>LClient</classname> proxy.</para><programlisting> <![CDATA[#include <utility> #include <string>#include <vector>typedef pair<float, float> rectangle;class LignariusClientProtocol { public: 	virtual ~LignariusClientProtocol() {} 	virtual void registerWithServer(const string &serverName, 									const string &hostName) = 0; 	virtual vector<rectangle>& getCutList() = 0; 	virtual void completedWork(vector<rectangle>& cl) = 0;	bool terminated; };class LignariusClientFactory { public: 	static LignariusClientProtocol* newLignariusClient(); }; ]]></programlisting><para>Earlier we mentioned that we would be using a factory to create our Objective-C++ object. Our C++ code can include the above header, which doesn't include any Objective-C code, and grab a new <classname>LignariusClient</classname> using the following factory method implementation:</para><programlisting><![CDATA[#include "LignariusClient.h"LignariusClientProtocol* LignariusClientFactory::newLignariusClient() {	return (new LignariusClient); } ]]></programlisting><para>Notice in <xref linkend="UHOC:ocfromcpp"/> that interaction between the C++ and Objective-C objects goes both directions: as with many Objective-C objects, when making DO connections there is a delegate. In our case, we want to feed this delegate information back to C++ objects. We need to feed an Objective-C object to <classname>LClient</classname> when it makes its DO connection, but have that object call back into a C++ object. So, our Objective-C++ interface has two classes declared. One in C++, and one in Objective-C.</para><programlisting> <![CDATA[#include <Foundation/Foundation.h>#include "LignariusClientProtocol.h" #import "LClient.h"class LignariusClient;@interface LignariusClientCallback : NSObject { 	LignariusClient *callback; 	LClient *client; } - (id)initWithCallback:(LignariusClient*)cb lClient:(LClient*)lc; @endclass LignariusClient : public LignariusClientProtocol { public:	LignariusClient(); 	virtual ~LignariusClient(); 	void registerWithServer(const string &serverName, const string &hostName);	vector<rectangle>& getCutList(); 	void completedWork(vector<rectangle> &cl); 	void serverTerminated(bool term);private: 	LClient *client; 	LignariusClientCallback *cbProxy;	vector<rectangle> rectangles; }; ]]></programlisting><para>The Objective-C object is our DO callback, and the C++ object implements the protocl we defined earlier. Here is the implementation files for both the Objective-C and C++ classes:</para><programlisting><![CDATA[#import <Foundation/Foundation.h> #include "LignariusClient.h"@implementation LignariusClientCallback- (id)initWithCallback:(LignariusClient*)cb lClient:(LClient*)lc {	if(self = [super init]) { 		callback = cb; 		client = lc; 		[client setDelegate:self]; 	} 	return self; }- (void)serverTerminatingForClient:(LClient*)lClient { 	if(client = lClient) 		callback->serverTerminated(true); }@endLignariusClient::LignariusClient() { 	client = [[LClient alloc] init];	cbProxy = [[LignariusClientCallback alloc] initWithCallback:this														lClient:client]; }LignariusClient::~LignariusClient() { 	[client release]; 	[cbProxy release]; }void LignariusClient::registerWithServer(const string &serverName, 										 const string &hostName) { 	[client registerWithServerName:[NSString				 stringWithCString:serverName.c_str()] 				          hostName:[NSString 										stringWithCString:hostName.c_str()]]; }vector<rectangle>& LignariusClient::getCutList() { 	// ... 	[client getCutList]; 	return rectangles; }void LignariusClient::completedWork(vector<rectangle> &cl) { 	// ...	NSDictionary* dict = [[NSDictionary alloc] init]; 	[client completedWork:dict]; }void  LignariusClient::serverTerminated(bool term) { 	terminated = term;} ]]></programlisting><para>As with handling C++ objects from Objective-C, the C++ object model does not automatically take into account the reference counting and autorelease pools of Objective-C. The C++ runtime will not automatically call Objective-C constructors or destructors. When you are finished with an Objective-C object, make sure you properly release it if necessary.</para><para>Finally, we can see the pure C++ <function>main()</function> implementation.</para><programlisting> <![CDATA[#include <iostream> #include "LignariusClientProtocol.h"int main (int argc, const char * argv[]) { 	// insert code here... 	cout << "Starting Client...\n";	LignariusClientProtocol* c = LignariusClientFactory::newLignariusClient();	while(!c->terminated) { 		vector<rectangle> cl = c->getCutList();		// do our work // ...		c->completedWork(cl); 	} 	cout << "Completed\n"; 	return 0; }]]></programlisting>	</sect1>		<sect1>		<title>Things to Watch Out For</title><para>There are several limitations to keep in mind when using Objective-C++.These limitations arise from the fact that when a program incorporatingObjective-C and C++ code is run, the runtime systems that support eachlanguage are entirely separate, and therefore do not know how to handleeach other's objects. For example, you cannot use Objective-C messagingsyntax on C++ objects, or intermingle C++ and Objective-C classhierarchies. Check the release notes for a full list of specificlanguage limitations (see <xref linkend="UHOC:resources"/>). In most cases,if you follow the design suggestion of properly insulating yourObjective-C and C++ code from each other, you can avoid many of theproblems; however, there are a still a couple of issues with usingObjective-C++ you may want to consider.</para><para>Using the different exception systems from C++ and Objective-C can be alittle tricky. Objective-C's NSException class uses the<function>setjmp</function>, <function>longjmp</function> calls, while C++'s exception system is build into the language and run-time support. Mixing Objective-C and C++ code that might throw exceptions takes a little extra effort.</para><para>Like almost all compilers on the market, support for the full C++standard in <command>gcc</command> is not always what one would hope for. The C++ standard, including the STL, is enormous, and it takes time to implementevery feature, and even when a feature is implemented, it may not bestable. The latest <application>ProjectBuilder</application> release includes <command>gcc</command> version 3.1, which has much better support for the C++ standard <!--??? note: check before book goes out to get latest updates ???--> Particularly troublesome for the compiler and library vendors has been full support for generic programming and templates. Many advanced C++ computationallibraries make use of more subtle template features, and test compilerimplementations to their breaking point. As a rule of thumb, if the C++code you are interested in using works with <command>gcc</command>, you should be okay.</para><para>Both Objective-C and C++ impose an overhead on applications overstraight C. When you combine the two, you get the overhead of both. Whatdoes this mean in practical terms? The first hit you will take is incompile speed. <command>gcc</command> is not fast at the best of times, so youcan expect its speed on the Objective-C++ portions of your code to beslower than C or Objective-C alone. <command>gcc</command> is always gettingbetter in this regard, and there are ways to speed up your compiletimes.</para><blockquote><para>NOTE: Currently, <application>ProjectBuilder</application> does not bydefault precompile headers for Objective-C++ code. This can lead to longcompile times when including C++ code in your projects. In order to turnon pre-compiled headers, use the <literal>-cpp-precomp</literal> option. Newerversions of <application>ProjectBuilder</application> include <command>GCC</command> 3.1, or newer, and support an entirely new pre-compiled header system. <olink targetptr="FOUND" targetdoc="Foundations"/> covers how to use pre-compiled headers in the latest version of <application>ProjectBuilder</application>.<!--??? Note: check this before book goes out to get the latest release info on dev tools ???--></para></blockquote><para>The second hit you will take with Objective-C++ is in application size.However, this is a relatively small penalty. For a minimal program,compiling the same code as Objective-C and again as Objective-C++results in a 4KB difference. If you have <command>gcc</command> generatedebugging symbols, the Objective-C++ code will be much larger in orderto include the extra information. Application file size is only one halfof the equation. You will also see an increase in the runtime memoryrequirements of your application as it will require the C++ libraries inorder to run. As long as you do not statically link the libraries, thiscost is amortized over all of the C++ applications running the sharedlibrary.</para><para>Luckily, there is really no impact on the runtime speed of yourapplication after you have compiled your code as Objective-C++ insteadof Objective-C. One of C++'s goals has been to avoid imposing overheadfor features programmers are not using. This is one reason garbagecollection has been avoided in the standard for such a long time. If youare not using a feature of C++, then you should not see an impact on theruntime performance of your application, apart from the pressure loadinglarger libraries creates on the memory subsystem. In general, this willonly be apparent during program loading, and low memory situations,where the system is forced to swap pages to and from disk to supportyour application.</para><para>With many high performance libraries already in existence for C and C++,the ability to seamlessly integrate this code into &cocoa; applicationscan save you the effort of reinventing the wheel. If you need to useC++, Objective-C++ is a great tool to have around. Apple's developertools let you incorporate mixed C, C++ and Objective-C code all in oneapplication. For this reason, don't think of Objective-C++ as adifferent language, but more of a C++ compatibility switch you can throwin Objective-C when needed.</para>	</sect1></chapter>